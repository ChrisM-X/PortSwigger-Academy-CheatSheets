# HTTP Host Header Attacks

## Summary

* [Recon for HTTP Host Header Attacks](#recon)

* [Portswigger Labs Cheat Sheet / Payloads](#cheat-sheet)

* Additional Note: There is a PDF attached in this folder that has a walk-through of the labs. The document does not need to be downloaded, it can be viewed inline in GitHub.


<br><br>

## Recon

### __Check out these pages for how to test for vulnerabilities in Host header and different validation bypass techniques:__

* https://portswigger.net/web-security/host-header/exploiting#how-to-test-for-vulnerabilities-using-the-http-host-header

* https://portswigger.net/web-security/ssrf#circumventing-common-ssrf-defenses

* https://portswigger.net/web-security/cors#errors-parsing-origin-headers

<br>

* Overview:

    * To test whether a website is vulnerable to attack via the HTTP Host header, you will need an intercepting proxy, such as Burp Proxy, and manual testing tools like Burp Repeater and Burp Intruder. 

    * Important:  In short, you need to identify whether you are able to modify the Host header and still reach the target application with your request. If so, you can use this header to probe the application and observe what effect this has on the response. 

    * Burp Suite accurately maintains the separation between the Host header and the target IP address. This separation allows you to supply any arbitrary or malformed Host header that you want, while still making sure that the request is sent to the intended target.


<br><br>

## Cheat Sheet

<br>

### __Basic password reset poisoning__

* If the application exposes a password reset functionality, determine how the application is generating the password reset URL.  It may be possible to inject a malicious domain in that URL by manipulating the Host header or including other headers such as X-Forwarded-Host.

* In the labs, use the Exploit Server’s email client to test the functionality and see if the domain is dynamically generated by user controllable input.

* Example:

   * Host: Exploit-Server.net


<br><br>

### __Web cache poisoning via ambiguous requests__

* When probing for potential Host header attacks, you will often come across seemingly vulnerable behavior that isn't directly exploitable. For example, you may find that the Host header is reflected in the response markup without HTML-encoding, or even used directly in script imports. Reflected, client-side vulnerabilities, such as XSS, are typically not exploitable when they're caused by the Host header. There is no way for an attacker to force a victim's browser to issue an incorrect host in a useful manner.

* Using Burp Suite, add another Host header in the HTTP request with an arbitrary value and identify if the application is using the value in the HTTP responses in an unsafe way.

* Example:

   * Host: test

   * Host: normal-host

* Host headers are typically not part of the cache key, so if the application is using a web cache and the malicious payload is cached in the HTTP response, the malicious payload will still reach other user’s normal HTP requests.

* Example:

* The application is grabbing the value from the additional Host header and dynamically generating a JavaScript source file.  Use the lab’s Exploit Server to host malicious content using the same file path/endpoint.  Then poison the cache with the Exploit Server’s domain using the Host header.  Ensure the "Content-Type" header has the correct mime type.

* https://user-controllable-domain/resources/file.js   - ensure that in the Exploit Server the payload is under the same path (/resources/file.js)

<br><br>

### __Host header authentication bypass__

* If the /admin endpoint is only available to users on the localhost network, we can try injecting the local host values like so with either of these headers:

    * Host: localhost

    * X-Forwarded-Host: localhost

* If that does not work try to encode/obfuscate the header's value or add double Host headers.


<br><br>

### __Routing-based SSRF__

* The host headers can be used to perform a SSRF attack.

* Replace the original Host header value with another domain and determine if the application initiates a request to the domain.  Burp Collaborator can be used here for testing.

* If this works, then it means the application is vulnerable to SSRF through the Host header.

* It is required to use Burp Suite, since the tool accurately maintains the separation between the Host header and the target IP address.

* This can be used to access the /admin panel of the application, as the SSRF payload will target an internal IP address.  Use Burp Intruder to brute force if needed.:

* Example:

   * GET /admin HTTP/2

   * Host: 192.168.0.2

<br><br>

### __SSRF via flawed request parsing__

* The host headers can be used to perform a SSRF attack.

* Replace the original Host header value with another domain and determine if the application initiates a request to the domain.  Burp Collaborator can be used here for testing.

* If this does not work, then use an additional Host header or the X-Forwarded-Host header, for example.

* Another technique to try is to supply an absolute URL in the request line:

    * GET https://vulnerable-website.com/admin HTTP/2

    * Host: bad-stuff-here - 192.168.0.1

* If this works, then it means the application is vulnerable to SSRF through the Host header, while injecting the absolute URL of the application in the request line.


<br><br>

### __Host validation bypass via connection state attack__

* Poorly implemented HTTP servers sometimes work on the dangerous assumption that certain properties, such as the Host header, are identical for all HTTP/1.1 requests sent over the same connection.

* For example, you may occasionally encounter servers that only perform thorough validation on the first request they receive over a new connection. In this case, you can potentially bypass this validation by sending an innocent-looking initial request then following up with your malicious one down the same connection.

* To attack the application using the connection state attack.

* Use Burp Repeater and place 2 different tabs into a new group, then change the send mode to "Send group in sequence (single connection)".

* Ensure the first tab contains the normal HTTP request.  The second tab can contain the malicious HTTP request.  Same techniques as previous examples, can be used here.

<br><br>


### Pending to complete labs that are missing from cheat sheet:

* LAB EXPERT Password reset poisoning via dangling markup
